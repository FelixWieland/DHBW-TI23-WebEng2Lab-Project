const e=/\{[^{}]+\}/g,t=({allowReserved:e,name:t,value:r})=>{if(null==r)return"";if("object"==typeof r)throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${e?r:encodeURIComponent(r)}`},r=({allowReserved:e,explode:r,name:a,style:s,value:n})=>{if(!r){const t=(e?n:n.map((e=>encodeURIComponent(e)))).join((e=>{switch(e){case"form":default:return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20"}})(s));switch(s){case"label":return`.${t}`;case"matrix":return`;${a}=${t}`;case"simple":return t;default:return`${a}=${t}`}}const o=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(s),l=n.map((r=>"label"===s||"simple"===s?e?r:encodeURIComponent(r):t({allowReserved:e,name:a,value:r}))).join(o);return"label"===s||"matrix"===s?o+l:l},a=({allowReserved:e,explode:r,name:a,style:s,value:n})=>{if("deepObject"!==s&&!r){let t=[];Object.entries(n).forEach((([r,a])=>{t=[...t,r,e?a:encodeURIComponent(a)]}));const r=t.join(",");switch(s){case"form":return`${a}=${r}`;case"label":return`.${r}`;case"matrix":return`;${a}=${r}`;default:return r}}const o=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(s),l=Object.entries(n).map((([r,n])=>t({allowReserved:e,name:"deepObject"===s?`${a}[${r}]`:r,value:n}))).join(o);return"label"===s||"matrix"===s?o+l:l},s=({allowReserved:e,array:s,object:n}={})=>o=>{let l=[];if(o&&"object"==typeof o)for(const i in o){const c=o[i];null!=c&&(l=Array.isArray(c)?[...l,r({allowReserved:e,explode:!0,name:i,style:"form",value:c,...s})]:"object"!=typeof c?[...l,t({allowReserved:e,name:i,value:c})]:[...l,a({allowReserved:e,explode:!0,name:i,style:"deepObject",value:c,...n})])}return l.join("&")},n=({baseUrl:s,path:n,query:o,querySerializer:l,url:i})=>{let c=s+(i.startsWith("/")?i:`/${i}`);n&&(c=(({path:s,url:n})=>{let o=n;const l=n.match(e);if(l)for(const e of l){let n=!1,l=e.substring(1,e.length-1),i="simple";l.endsWith("*")&&(n=!0,l=l.substring(0,l.length-1)),l.startsWith(".")?(l=l.substring(1),i="label"):l.startsWith(";")&&(l=l.substring(1),i="matrix");const c=s[l];null!=c&&(o=Array.isArray(c)?o.replace(e,r({explode:n,name:l,style:i,value:c})):"object"!=typeof c?"matrix"!==i?o.replace(e,"label"===i?`.${c}`:c):o.replace(e,`;${t({name:l,value:c})}`):o.replace(e,a({explode:n,name:l,style:i,value:c})))}return o})({path:n,url:c}));let u=o?l(o):"";return u.startsWith("?")&&(u=u.substring(1)),u&&(c+=`?${u}`),c},o=(...e)=>{const t=new Headers;for(const r of e){if(!r||"object"!=typeof r)continue;const e=r instanceof Headers?r.entries():Object.entries(r);for(const[r,a]of e)if(null===a)t.delete(r);else if(Array.isArray(a))for(const e of a)t.append(r,e);else void 0!==a&&t.set(r,"object"==typeof a?JSON.stringify(a):a)}return t};class l{_fns;constructor(){this._fns=[]}eject(e){const t=this._fns.indexOf(e);-1!==t&&(this._fns=[...this._fns.slice(0,t),...this._fns.slice(t+1)])}use(e){this._fns=[...this._fns,e]}}const i=()=>({request:new l,response:new l}),c=(e,t,r)=>{"string"==typeof r||r instanceof Blob?e.append(t,r):e.append(t,JSON.stringify(r))},u={bodySerializer:e=>{const t=new FormData;return Object.entries(e).forEach((([e,r])=>{null!=r&&(Array.isArray(r)?r.forEach((r=>c(t,e,r))):c(t,e,r))})),t}},d={bodySerializer:e=>JSON.stringify(e)},p=s({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),f={"Content-Type":"application/json"},h=()=>({...d,baseUrl:"",fetch:globalThis.fetch,global:!0,headers:f,querySerializer:p});let b=h();const m=i(),y=e=>{const t=h(),r={...t,...e};r.baseUrl?.endsWith("/")&&(r.baseUrl=r.baseUrl.substring(0,r.baseUrl.length-1)),r.headers=o(t.headers,r.headers),r.global&&(b={...r});const a=()=>r.global?b:r,l=r.global?m:i(),c=async e=>{const t=a(),r={...t,...e,headers:o(t.headers,e.headers)};r.body&&r.bodySerializer&&(r.body=r.bodySerializer(r.body));const i=n({baseUrl:r.baseUrl??"",path:r.path,query:r.query,querySerializer:"function"==typeof r.querySerializer?r.querySerializer:s(r.querySerializer),url:r.url}),c={redirect:"follow",...r};c.body instanceof FormData&&c.headers.delete("Content-Type");let u=new Request(i,c);for(const e of l.request._fns)u=await e(u,r);const d=r.fetch;let p=await d(u);for(const e of l.response._fns)p=await e(p,u,r);const f={request:u,response:p};if(204===p.status||"0"===p.headers.get("Content-Length"))return p.ok?{data:{},...f}:{error:{},...f};if(p.ok){if("stream"===r.parseAs)return{data:p.body,...f};const e="auto"===r.parseAs?(e=>{if(e)return"application/json"===e||e.endsWith("+json")?"json":"multipart/form-data"===e?"formData":["application/octet-stream","application/pdf","application/zip","audio/","image/","video/"].some((t=>e.includes(t)))?"blob":e.includes("text/")?"text":void 0})(p.headers.get("Content-Type")):r.parseAs;return{data:await p[e??"json"](),...f}}let h=await p.text();try{h=JSON.parse(h)}catch{}return{error:h,...f}};return{connect:e=>c({...e,method:"CONNECT"}),delete:e=>c({...e,method:"DELETE"}),get:e=>c({...e,method:"GET"}),getConfig:a,head:e=>c({...e,method:"HEAD"}),interceptors:l,options:e=>c({...e,method:"OPTIONS"}),patch:e=>c({...e,method:"PATCH"}),post:e=>c({...e,method:"POST"}),put:e=>c({...e,method:"PUT"}),request:c,trace:e=>c({...e,method:"TRACE"})}},w=y(b);export{w as client,y as createClient,u as formDataBodySerializer,d as jsonBodySerializer};
