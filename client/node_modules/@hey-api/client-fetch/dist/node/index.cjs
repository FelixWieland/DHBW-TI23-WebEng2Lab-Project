"use strict";const e=/\{[^{}]+\}/g,t=({allowReserved:e,name:t,value:r})=>{if(null==r)return"";if("object"==typeof r)throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${e?r:encodeURIComponent(r)}`},r=({allowReserved:e,explode:r,name:a,style:s,value:o})=>{if(!r){const t=(e?o:o.map((e=>encodeURIComponent(e)))).join((e=>{switch(e){case"form":default:return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20"}})(s));switch(s){case"label":return`.${t}`;case"matrix":return`;${a}=${t}`;case"simple":return t;default:return`${a}=${t}`}}const n=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(s),l=o.map((r=>"label"===s||"simple"===s?e?r:encodeURIComponent(r):t({allowReserved:e,name:a,value:r}))).join(n);return"label"===s||"matrix"===s?n+l:l},a=({allowReserved:e,explode:r,name:a,style:s,value:o})=>{if("deepObject"!==s&&!r){let t=[];Object.entries(o).forEach((([r,a])=>{t=[...t,r,e?a:encodeURIComponent(a)]}));const r=t.join(",");switch(s){case"form":return`${a}=${r}`;case"label":return`.${r}`;case"matrix":return`;${a}=${r}`;default:return r}}const n=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(s),l=Object.entries(o).map((([r,o])=>t({allowReserved:e,name:"deepObject"===s?`${a}[${r}]`:r,value:o}))).join(n);return"label"===s||"matrix"===s?n+l:l},s=({allowReserved:e,array:s,object:o}={})=>n=>{let l=[];if(n&&"object"==typeof n)for(const i in n){const c=n[i];null!=c&&(l=Array.isArray(c)?[...l,r({allowReserved:e,explode:!0,name:i,style:"form",value:c,...s})]:"object"!=typeof c?[...l,t({allowReserved:e,name:i,value:c})]:[...l,a({allowReserved:e,explode:!0,name:i,style:"deepObject",value:c,...o})])}return l.join("&")},o=({baseUrl:s,path:o,query:n,querySerializer:l,url:i})=>{let c=s+(i.startsWith("/")?i:`/${i}`);o&&(c=(({path:s,url:o})=>{let n=o;const l=o.match(e);if(l)for(const e of l){let o=!1,l=e.substring(1,e.length-1),i="simple";l.endsWith("*")&&(o=!0,l=l.substring(0,l.length-1)),l.startsWith(".")?(l=l.substring(1),i="label"):l.startsWith(";")&&(l=l.substring(1),i="matrix");const c=s[l];null!=c&&(n=Array.isArray(c)?n.replace(e,r({explode:o,name:l,style:i,value:c})):"object"!=typeof c?"matrix"!==i?n.replace(e,"label"===i?`.${c}`:c):n.replace(e,`;${t({name:l,value:c})}`):n.replace(e,a({explode:o,name:l,style:i,value:c})))}return n})({path:o,url:c}));let u=n?l(n):"";return u.startsWith("?")&&(u=u.substring(1)),u&&(c+=`?${u}`),c},n=(...e)=>{const t=new Headers;for(const r of e){if(!r||"object"!=typeof r)continue;const e=r instanceof Headers?r.entries():Object.entries(r);for(const[r,a]of e)if(null===a)t.delete(r);else if(Array.isArray(a))for(const e of a)t.append(r,e);else void 0!==a&&t.set(r,"object"==typeof a?JSON.stringify(a):a)}return t};class l{_fns;constructor(){this._fns=[]}eject(e){const t=this._fns.indexOf(e);-1!==t&&(this._fns=[...this._fns.slice(0,t),...this._fns.slice(t+1)])}use(e){this._fns=[...this._fns,e]}}const i=()=>({request:new l,response:new l}),c=(e,t,r)=>{"string"==typeof r||r instanceof Blob?e.append(t,r):e.append(t,JSON.stringify(r))},u={bodySerializer:e=>{const t=new FormData;return Object.entries(e).forEach((([e,r])=>{null!=r&&(Array.isArray(r)?r.forEach((r=>c(t,e,r))):c(t,e,r))})),t}},d={bodySerializer:e=>JSON.stringify(e)},p=s({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),f={"Content-Type":"application/json"},h=()=>({...d,baseUrl:"",fetch:globalThis.fetch,global:!0,headers:f,querySerializer:p});let y=h();const b=i(),m=e=>{const t=h(),r={...t,...e};r.baseUrl?.endsWith("/")&&(r.baseUrl=r.baseUrl.substring(0,r.baseUrl.length-1)),r.headers=n(t.headers,r.headers),r.global&&(y={...r});const a=()=>r.global?y:r,l=r.global?b:i(),c=async e=>{const t=a(),r={...t,...e,headers:n(t.headers,e.headers)};r.body&&r.bodySerializer&&(r.body=r.bodySerializer(r.body));const i=o({baseUrl:r.baseUrl??"",path:r.path,query:r.query,querySerializer:"function"==typeof r.querySerializer?r.querySerializer:s(r.querySerializer),url:r.url}),c={redirect:"follow",...r};c.body instanceof FormData&&c.headers.delete("Content-Type");let u=new Request(i,c);for(const e of l.request._fns)u=await e(u,r);const d=r.fetch;let p=await d(u);for(const e of l.response._fns)p=await e(p,u,r);const f={request:u,response:p};if(204===p.status||"0"===p.headers.get("Content-Length"))return p.ok?{data:{},...f}:{error:{},...f};if(p.ok){if("stream"===r.parseAs)return{data:p.body,...f};const e="auto"===r.parseAs?(e=>{if(e)return"application/json"===e||e.endsWith("+json")?"json":"multipart/form-data"===e?"formData":["application/octet-stream","application/pdf","application/zip","audio/","image/","video/"].some((t=>e.includes(t)))?"blob":e.includes("text/")?"text":void 0})(p.headers.get("Content-Type")):r.parseAs;return{data:await p[e??"json"](),...f}}let h=await p.text();try{h=JSON.parse(h)}catch{}return{error:h,...f}};return{connect:e=>c({...e,method:"CONNECT"}),delete:e=>c({...e,method:"DELETE"}),get:e=>c({...e,method:"GET"}),getConfig:a,head:e=>c({...e,method:"HEAD"}),interceptors:l,options:e=>c({...e,method:"OPTIONS"}),patch:e=>c({...e,method:"PATCH"}),post:e=>c({...e,method:"POST"}),put:e=>c({...e,method:"PUT"}),request:c,trace:e=>c({...e,method:"TRACE"})}},j=m(y);exports.client=j,exports.createClient=m,exports.formDataBodySerializer=u,exports.jsonBodySerializer=d;
